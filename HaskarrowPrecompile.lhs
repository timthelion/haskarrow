>module HaskarrowPrecompile where

import Debug.Trace

require her-lexer >= 0.1 from cabal

>import Language.Haskell.Her.HaLay
>import Language.Haskell.Her.FromClutterToLines

require cpphs from cabal

>import Language.Preprocessor.Unlit

require split from cabal

>import Data.List.Split

>import Data.Graph

This is in unprocessed form.  That is, it maintains the IO type and any newlines.

>type Type = [Tok]

>data Value = Value {
> valueType    :: Type    ,
> valueName    :: String  ,
> valueDepends :: [String],
> valueVariety :: ValueVariety} deriving (Show)

We have different varieties of values now. The old run of the mill ones were getting a bit boring.

There are values declared like this:

myImediatelyResolvedValue :: Foo -> Bar -> IO Lollypop
myImediatelyResolvedValue foo bar <<
 do me

These values are resolved when initValues is run.  No questions asked.

Then there are values that are declared like this:

myMaybeImediatelyResolvedValue :: Foo -> IO IceCream
myMaybeImediatelyResolvedValue foo <?<
 do me

Functions that have these types are passed as arguments to initValues.  For example if you wanted to pass your OWN version of myMaybeImediatelyResolvedValue, you would pass a value of type (Maybe (Foo -> IO IceCream)) to initValues.  If you DIDN'T want to use your own version, you would pass Nothing.

Then there are values that are declared like THIS:

myCertainlyNeededValue :: Lollipop -> IO Lollipop
myCertianlyNeededValue lollipop ?

You see, there wasn't a "do me" after the ? There isn't one.  These values are non optional arguments of initValues.  If there is even just one CertainlyNeeded value in your entire module, guess what? Haskarrow cannot generate a main statement for your module, because it's missing a value.  This is only used if you are going to be creating non independent application parts....

The last type of value is really boring.  It's declaration looks like this:

myStaticValue :: Woot -> Bzaptdphlegm -> [Bzaaptdphlegm]
myStaticValue woot bzaptdphlegm = woot bzaptdphlegm : []

It doesn't get evaluated, in the IO sense, at all.  It's just a normal function.  Though watch out.  It's got some special qualities of it's own. This function will be renamed by haskarrow to myStaticValueValue(like all values) and then it will become a record in the Values data type.

>data ValueVariety =
> ImediateResolution      |
> MaybeImediateResolution |
> CertainlyNeeded         |
> StaticValue deriving (Show,Eq)

>data ValueBuilder =
> NoValue            |
> ValueWithType Type |
> ValueWithTypeAndNameAndDepends Type String [String] |
> ValueBody deriving (Show)

>type Error = String

Returns either HaskellCode OR AnError

>precompile :: String -> FilePath -> Either String Error
>precompile origionalSource fileName=
> let
>  eitherValuesAndFunctionsOrAnError = expandFunctions origionalSource fileName
> in
>  case eitherValuesAndFunctionsOrAnError of
>   Left (values, functions,topLevel) ->
>    case resolveDependencies values of
>     Left values' -> Left ("{- AUTOGENERATED BY HASKARROW -}"++functions ++ "\n" ++ (generateDataDeclaration values' topLevel) ++ (generateInit values' topLevel) ++ (mainCode topLevel values'))
>     Right error -> Right error
>   Right error -> Right error

Returns what it should, or an error message.

| OK, the idea of this function, is that we look through the lines. When we get to a line that meets our pattern(beggining with a Lid), we start actually processing.  We add lines begining with a Lid to our our list of Values, and we transform the source code into proper haskell at the same time.  We then use these values later on to do even more source code generation.

>expandFunctions :: String -> FilePath -> Either ([Value], String, Int) Error
>expandFunctions origionalSource fileName = 
> let

We take the Toks generated by her-lexer

>  tokss :: [[Tok]]
>  tokss = fromClutterToLines $ ready fileName $ unlit fileName origionalSource

>  eatTillLidFoundThenContinueProcessingNormally :: [[Tok]] -> [[Tok]] -> Either ([Value],String,Int) Error

>  eatTillLidFoundThenContinueProcessingNormally processedToks ((toks@((NL _):(Spc _):(Lid _):_)):tokss) =
>   processToks processedToks (toks:tokss) (indentLevel toks) NoValue []

>  eatTillLidFoundThenContinueProcessingNormally processedToks ((toks@((NL _):(Lid _):_)):tokss) =
>   processToks processedToks (toks:tokss) (indentLevel toks) NoValue []

>  eatTillLidFoundThenContinueProcessingNormally processedToks (toks:tokss) =
>   eatTillLidFoundThenContinueProcessingNormally (processedToks++(toks:[])) tokss

>  eatTillLidFoundThenContinueProcessingNormally _ [] = Right ("Error, no values found, are you sure this is a valid haskarrow file?\n" ++ (show tokss))

>  processToks :: [[Tok]] -> [[Tok]] -> Int -> ValueBuilder -> [Value] -> Either ([Value],String,Int) Error

If our ValueBuilder currently has no value, than we are expecting to find a type.

>  processToks processedToks (toks:tokss) topLevel NoValue processedValues =
>   let

If the line contains a keyword(KW) we ignore it.

>    keyword = any (\tok -> case tok of
>                            KW _ -> True
>                            _    -> False) toks

>    eatType :: [Tok] -> Either ([Tok],[Tok]) Error
>    eatType toks =
>     let
>      typeToks' =
>       filter (\tok->
>                 case tok of
>                  (T Ty _)->True
>                  _               ->False)
>              toks
>      fullToks =
>       map (\tok ->
>             case tok of
>              (Lid name) -> (Lid (name++"Value"))
>              tok' -> tok')
>           toks
>     in
>     if not $ null typeToks'
>     then 
>      let
>       ((T Ty typeToks):_) = typeToks'
>      in
>       Left (fullToks,typeToks)
>     else Right ("Could not parse the line:\n"++
>                 (toksOut toks) ++
>                "\nRemember that haskarrow ALWAYS expects a type declaration."++
>                "And that this type declaration should come before the value.")
>   in case (eatType toks,keyword) of
>    (Left (fullToks,typeToks),False) ->
>     let 

This is the most beautiful(I mean hackish) use of laziness ever...  We hand processToksSniff our list of processedToks, even though we CANNOT yet actually populate that list, because we are waiting on the result of processToksSniff to tell us if our current value is a ? (CertainlyNeeded) value which must be ignored.

>      (ignore,normalResult)=processToksSniff (processedToks++((if ignore then Sym "{-" : fullToks else fullToks):[])) tokss topLevel (ValueWithType typeToks) processedValues 
>     in normalResult

Ignore keyword lines.

>    (_,True) ->
>     processToks (processedToks++(toks:[])) tokss topLevel NoValue processedValues 
>    (Right errorString,_) -> Right errorString 

WARNING!  This is out of order.  If you are reading this source code, jump down to processToksSnif, and then come back up here and keep reading.

Here we eat the body of the value, if any.

>  processToks processedToks (toks:tokss) topLevel ValueBody processedValues =
>   if indentLevel toks /= topLevel

We actually end up just ignoring the body of the value declaration.

>   then processToks (processedToks++(toks:[])) tokss topLevel ValueBody processedValues
>   else processToks processedToks (toks:tokss) topLevel NoValue processedValues

If we run out of lines to process, then we're done :)

>  processToks processedToks [] topLevel NoValue processedValues = Left (processedValues,tokssOut processedToks,topLevel)
>  processToks processedToks [] topLevel ValueBody processedValues = Left (processedValues,tokssOut processedToks,topLevel)

>  processToks processedToks [] topLevel valueBuilder processedValues = Right ("Incomplete Value declaration, end of file reached unexpectedly. The final value builder object was:\n"++(show valueBuilder))

Returns True if the value turns out to be a ? which has to be ignored, or False if the value turns out to be a normal value...

>  processToksSniff ::  [[Tok]] -> [[Tok]] -> Int -> ValueBuilder -> [Value] -> (Bool,Either ([Value],String,Int) Error)
>  processToksSniff processedToks (toks:tokss) topLevel (ValueWithType typeToDate) processedValues =

If we are currently processing a type, then we check if our current line is of a level bellow the top.  If so, the code is probably invalid but we ignore this since I cannot think of a proof that the code is invalid so I'll just let GHC choke on it, otherwise we start processing the value.


>   if indentLevel toks > topLevel
>   then processToksSniff (processedToks++(toks:[])) tokss topLevel (ValueWithType typeToDate) processedValues
>   else

When processing that value, we can either complete the opperation in this round, if we find a <<, or we have to continue building our list of depends untill we come to a <<.

>    case scoopDeclarationAndDependsWithRename toks of
>     Left ((name:depends),toks',Nothing) -> 
>       processToksSniff (processedToks++(toks':[])) tokss topLevel (ValueWithTypeAndNameAndDepends typeToDate name depends) processedValues
>     Left ((name:depends),toks',Just CertainlyNeeded) ->
>      (True,processToks (processedToks++(toks':[])) tokss topLevel ValueBody ((Value typeToDate name depends CertainlyNeeded):processedValues))
>     Left ((name:depends),toks',Just variety) ->
>      (False,processToks (processedToks++(toks':[])) tokss topLevel ValueBody ((Value typeToDate name depends variety):processedValues))

>     Left (_, [],_)   -> (False,Right ("Error parsing line:\n"++(toksOut toks)++"\nExpected a value declaration, no viable value name found."))
>     Right scoopError -> (False,Right scoopError)

This only happens if we have multiple lines before the <<

>  processToksSniff processedToks (toks:tokss) topLevel (ValueWithTypeAndNameAndDepends typeToDate name depends) processedValues =
>   case scoopDeclarationAndDepends toks of
>    Left (depends',toks', Just CertainlyNeeded) ->
>     (True,processToks (processedToks++(toks':[])) tokss topLevel ValueBody ((Value typeToDate name (depends++depends') CertainlyNeeded):processedValues))
>    Left (depends',toks', Just variety) ->
>     (False,processToks (processedToks++(toks':[])) tokss topLevel ValueBody ((Value typeToDate name (depends++depends') variety):processedValues))
>    Left (depends',toks', Nothing) ->
>     processToksSniff (processedToks++(toks':[])) tokss topLevel (ValueWithTypeAndNameAndDepends typeToDate name (depends++depends')) processedValues
>    Right scoopError -> (False,Right scoopError)

>   
> in eatTillLidFoundThenContinueProcessingNormally [] tokss

| From a line like:

foo someDepend anotherDepend << bar

scoop the name and the depends returning:

Left (["foo", "someDepend","anotherDepend"],[processedToks], (Just ImediateResolution))

From a line like:

foo someDepend
    anotherDepend << Bar

Return:

Left (["name","someDepend"],[processedToks]), Nothing)

>scoopDeclarationAndDepends :: [Tok] -> Either ([String],[Tok],Maybe ValueVariety) Error
>scoopDeclarationAndDepends toks = scoopDeclarationAndDepends' toks id [] []

Because we would get conflicting names if our functions where named the same as the values(record selectors) that they produced, we have to rename the functions.

>scoopDeclarationAndDependsWithRename :: [Tok] -> Either ([String],[Tok],Maybe ValueVariety) Error
>scoopDeclarationAndDependsWithRename toks = scoopDeclarationAndDepends' toks (\name->name++"Value") [] []

>scoopDeclarationAndDepends' :: [Tok] -> (String->String) -> [String] -> [Tok] -> Either ([String],[Tok], Maybe ValueVariety) Error
>scoopDeclarationAndDepends' ((Lid name):toks) rename [] processedToks = scoopDeclarationAndDepends' toks rename (name:[]) (processedToks++((Lid (rename name)):[]))
>scoopDeclarationAndDepends' ((Lid nameOrDepend):toks) rename nameAndDepends processedToks = scoopDeclarationAndDepends' toks rename (nameAndDepends++(nameOrDepend:[])) (processedToks++((Lid nameOrDepend):[]))
>scoopDeclarationAndDepends' ((Sym "<<"):toks) _ nameAndDepends processedToks = Left (nameAndDepends, (processedToks++((Sym "= "):toks)), Just ImediateResolution)
>scoopDeclarationAndDepends' ((Sym "<?<"):toks) _ nameAndDepends processedToks = Left (nameAndDepends, (processedToks++((Sym "= "):toks)), Just MaybeImediateResolution)
>scoopDeclarationAndDepends' ((Sym "?"):toks) _ nameAndDepends processedToks = Left (nameAndDepends, (processedToks++((Sym "=-} "):toks)), Just CertainlyNeeded)
>scoopDeclarationAndDepends' ((Sym "="):toks) _ nameAndDepends processedToks = Left (nameAndDepends, (processedToks++((Sym "= "):toks)), Just StaticValue)
>scoopDeclarationAndDepends' (spc@(Spc _):toks) rename nameAndDepends processedToks = scoopDeclarationAndDepends' toks rename nameAndDepends (processedToks++(spc:[]))
>scoopDeclarationAndDepends' (nl@(NL _):toks) rename nameAndDepends processedToks = scoopDeclarationAndDepends' toks rename nameAndDepends (processedToks++(nl:[]))
>scoopDeclarationAndDepends' [] _ nameAndDepends processedToks= Left (nameAndDepends,processedToks,Nothing)
>scoopDeclarationAndDepends' (tok:toks) rename nameAndDepends processedToks = Right ("Error #241, unexpected symbol in value declaration:\n"++(toksOut (tok:toks))++"\nThe symble was:\n"++(show tok))


>indentLevel :: [Tok] -> Int 
>indentLevel (nl@(NL _):spc@(Spc indent):toks) = length indent
>indentLevel (nl@(NL _):toks) = 0
>indentLevel [] = 0

>generateInit :: [Value] -> Int -> String
>generateInit values topLevel =
> "-- | This action loads a haskarrow module.  It returns a giant data constructor with reccords for each value loaded.\n" ++ 
> "-- initValues " ++ (concatMap (\value->' ':(valueName value)) values) ++ "\n" ++

 Ha!  I don't need to find the type. It'd be hard now that I'm taking arguments.  But GHC will do it for me :D :D :D
 (replicate topLevel ' ') ++ "initValues :: IO Values\n"++

> (replicate topLevel ' ')++"initValues " ++ (valuesWhichAreTakenAsArguments values) ++ "= do\n"++
> concatMap (\value ->initValueCode value topLevel) values ++
> (replicate (topLevel+1) ' ')++"return $ Values"++ (concatMap (\value->' ':(valueName value)) values) ++ "\n"
> where
>  valuesWhichAreTakenAsArguments :: [Value] -> String
>  valuesWhichAreTakenAsArguments values =
>   unwords $ map (\name -> name++"Parameter") $ map valueName $
>   filter (\value ->
>            valueVariety value == MaybeImediateResolution ||
>            valueVariety value == CertainlyNeeded) values

>initValueCode :: Value -> Int -> String
>initValueCode (Value valueType name depends ImediateResolution) topLevel =
> (replicate (topLevel+1)' ') ++ name ++ " <- " ++ (name++"Value") ++ (concatMap (\depend -> ' ':depend ++ " ") depends) ++ "\n"
>initValueCode (Value valueType name depends MaybeImediateResolution) topLevel =
> (replicate (topLevel+1)' ') ++ name ++ " <- case " ++ name++"Parameter of Nothing -> " ++ name ++ "Value" ++ (concatMap (\depend -> ' ':depend ++ " ") depends) ++ "; Just parameter -> parameter " ++ (concatMap (\depend -> ' ':depend ++ " ") depends) ++ "\n"
>initValueCode (Value valueType name depends CertainlyNeeded) topLevel =
> (replicate (topLevel+1)' ') ++ name ++ " <- " ++ (name++"Parameter") ++ (concatMap (\depend -> ' ':depend ++ " ") depends) ++ "\n"
>initValueCode (Value valueType name depends StaticValue) topLevel =
> (replicate (topLevel+1)' ') ++ name ++ " <- return " ++ (name++"Value") ++ "\n"

>generateDataDeclaration :: [Value] -> Int -> String
>generateDataDeclaration values topLevel =
> (replicate topLevel ' ')++"data Values = Values {\n" ++
> (tail (concatMap (\(Value valueType valueName _ valueVariety) -> ',':valueName ++ "::" ++ (clipType valueType valueVariety)++"\n") values)) ++
> " }\n"

>clipType :: [Tok] -> ValueVariety -> String

We don't butcher the type of static values(except for tossing the newlines).

>clipType toks StaticValue =  
>    toksOut $ 
>     filter (\elem -> case elem of
>                       (NL _) -> False
>                       _ -> True) toks

We do butcher the type of everything else.  That is we remove the parameters and the IO marker, since what we are really storring here is the result of having evaluated that function.

>clipType toks _ =
> let

First we split our type string so that we can focus on the last bit which is the only bit we are intrested in.

>  splitByArrows =
>   split (whenElt 
>           (\tok-> case tok of 
>                    (Sym "->") -> True 
>                    _ -> False))
>         toks 
> in
>  case reverse splitByArrows of
>   (lastType:_) ->

Then we remove that IO and convert the toks into a string of code(getting rid of any new lines).

>    toksOut $ 
>     filter (\elem -> case elem of
>                       (NL _) -> False
>                       _ -> True) $

>    (fst $ foldl (\(foldedToks,found) elem->
>            if not found && elem == (Uid "IO")
>            then (foldedToks,True)
>            else (foldedToks++(elem:[]),found))
>          ([],False)
>          lastType)

>mainCode :: Int -> [Value] -> String
>mainCode topLevel values = 
> let
>  numberOfOptionalParameters =
>   length $ filter (\value -> valueVariety value == MaybeImediateResolution) values
>  canMakeMain =
>   null $ filter (\value -> valueVariety value == CertainlyNeeded) values
> in
> if canMakeMain
> then
>  (replicate topLevel ' ') ++ "main :: IO ()\n"++
>  (replicate topLevel ' ')++"main = do myValues <- initValues "++ (unwords $ take numberOfOptionalParameters $ repeat "Nothing") ++" ; (exit myValues) ; return ()\n"
> else "{-NoMain-}"

>resolveDependencies :: [Value] -> Either [Value] Error
>resolveDependencies values =
> let
>  sortedValues :: [Value]

Don't be scared, we're just converting the Value's to tuples and back again, so we can use the graph lib to sort this "topoligically".

>  sortedValues = reverse $ map (\((n,v),k,ks)-> Value n k ks v) $ (\(g,v,_)->map v $ topSort g) $ graphFromEdges $ map (\(Value valueType valueName valueDepends valueVariety) -> ((valueType,valueVariety),valueName,valueDepends)) values
>  dependencyErrorMaybe :: Maybe Error
>  dependencyErrorMaybe = Nothing
> in
>  case dependencyErrorMaybe of
>   Just dependecyError -> Right dependecyError
>   Nothing -> Left sortedValues
