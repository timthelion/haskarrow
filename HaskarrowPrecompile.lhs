>module HaskarrowPrecompile where

>import HaskarrowPrecompile.DependencyResolver
>import HaskarrowPrecompile.Types
>import HaskarrowPrecompile.CodeGenerator
>import HaskarrowPrecompile.Parser

import Debug.Trace

require her-lexer >= 0.1 from cabal

import Language.Haskell.Her.HaLay
import Language.Haskell.Her.FromClutterToLines

require cpphs from cabal

import Language.Preprocessor.Unlit

require split from cabal

import Data.List.Split
import Data.List

import Data.Graph

↓ Returns either HaskellCode OR AnError ↓

>precompile ::
> String ->
> FilePath ->
> Either
>  Error
>  String

>precompile origionalSource fileName =
> let
>  eitherValuesAndFunctionsOrAnError =
>   expandFunctions origionalSource fileName
> in
>  case eitherValuesAndFunctionsOrAnError of
>   Right (values, functions,topLevel) ->
>    case resolveDependencies values of
>     Right values' ->
>      let
>       evaluated
>         =
>        areAnyValuesToBeEvaluated values'
>      in
>      Right ("{- AUTOGENERATED BY HASKARROW -}"++
>            functions ++ "\n" ++
>            (optionalParametersEmptyCode values' topLevel) ++
>            (requiredParametersDataDeclaration values' topLevel) ++
>            (optionalParametersDataDeclaration values' topLevel) ++
>            (valuesDataDeclaration values' topLevel) ++
>            (generateInit evaluated values' topLevel) ++
>            (if evaluated
>              then
>               (mainCode topLevel values')
>              else "{-NoMain, nothing to do.-}"))
>     Left error -> Left error
>   Left error -> Left error
