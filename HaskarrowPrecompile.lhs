>module HaskarrowPrecompile where

import Debug.Trace

require her-lexer >= 0.1 from cabal

>import Language.Haskell.Her.HaLay
>import Language.Haskell.Her.FromClutterToLines

require cpphs from cabal

>import Language.Preprocessor.Unlit

require split from cabal

>import Data.List.Split

>import Data.Graph

This is in unprocessed form.  That is, it maintains the IO type and any newlines.

>type Type = [Tok]

>data Value = Value {
> valueType    :: Type    ,
> valueName    :: String  ,
> valueDepends :: [String]} deriving (Show)

>data ValueBuilder =
> NoValue            |
> ValueWithType Type |
> ValueWithTypeAndNameAndDepends Type String [String] |
> ValueBody deriving (Show)

>type Error = String

Returns either HaskellCode OR AnError

>precompile :: String -> FilePath -> Either String Error
>precompile origionalSource fileName=
> let
>  eitherValuesAndFunctionsOrAnError = expandFunctions origionalSource fileName
> in
>  case eitherValuesAndFunctionsOrAnError of
>   Left (values, functions,topLevel) ->
>    case resolveDependencies values of
>     Left values' -> Left ("{- AUTOGENERATED BY HASKARROW -}"++functions ++ "\n" ++ (generateDataDeclaration values' topLevel) ++ (generateInit values' topLevel) ++ (mainCode topLevel))
>     Right error -> Right error
>   Right error -> Right error

Returns what it should, or an error message.

| OK, the idea of this function, is that we look through the lines. When we get to a line that meets our pattern(beggining with a Lid), we start actually processing.  We add lines begining with a Lid to our our list of Values, and we transform the source code into proper haskell at the same time.  We then use these values later on to do even more source code generation.

>expandFunctions :: String -> FilePath -> Either ([Value], String, Int) Error
>expandFunctions origionalSource fileName = 
> let

We take the Toks generated by her-lexer

>  tokss :: [[Tok]]
>  tokss = fromClutterToLines $ ready fileName $ unlit fileName origionalSource

>  eatTillLidFoundThenContinueProcessingNormally :: [[Tok]] -> [[Tok]] -> Either ([Value],String,Int) Error

>  eatTillLidFoundThenContinueProcessingNormally processedToks ((toks@((NL _):(Spc _):(Lid _):_)):tokss) =
>   processToks processedToks (toks:tokss) (indentLevel toks) NoValue []

>  eatTillLidFoundThenContinueProcessingNormally processedToks ((toks@((NL _):(Lid _):_)):tokss) =
>   processToks processedToks (toks:tokss) (indentLevel toks) NoValue []

>  eatTillLidFoundThenContinueProcessingNormally processedToks (toks:tokss) =
>   eatTillLidFoundThenContinueProcessingNormally (processedToks++(toks:[])) tokss

>  eatTillLidFoundThenContinueProcessingNormally _ [] = Right ("Error, no values found, are you sure this is a valid haskarrow file?\n" ++ (show tokss))

>  processToks :: [[Tok]] -> [[Tok]] -> Int -> ValueBuilder -> [Value] -> Either ([Value],String,Int) Error

If our ValueBuilder currently has no value, than we are expecting to find a type.

>  processToks processedToks (toks:tokss) topLevel NoValue processedValues =
>   let
>    eatType :: [Tok] -> Either ([Tok],[Tok]) Error
>    eatType toks =
>     let
>      typeToks' =
>       filter (\tok->
>                 case tok of
>                  (T Ty _)->True
>                  _               ->False)
>              toks
>      fullToks =
>       map (\tok ->
>             case tok of
>              (Lid name) -> (Lid (name++"Value"))
>              tok' -> tok')
>           toks
>     in
>     if not $ null typeToks'
>     then 
>      let
>       ((T Ty typeToks):_) = typeToks'
>      in
>       Left (fullToks,typeToks)
>     else Right ("Could not parse the line:\n"++
>                 (toksOut toks) ++
>                "\nRemember that haskarrow ALWAYS expects a type declaration."++
>                "And that this type declaration should come before the value.")
>   in case eatType toks of
>    Left (fullToks,typeToks) ->
>     processToks (processedToks++(fullToks:[])) tokss topLevel (ValueWithType typeToks) processedValues 
>    Right errorString -> Right errorString 

If we are currently processing a type, then we check if our current line is of a level bellow the top.  If so, the code is probably invalid but we ignore this since I cannot think of a proof that the code is invalid so I'll just let GHC choke on it, otherwise we start processing the value.
 
>  processToks processedToks (toks:tokss) topLevel (ValueWithType typeToDate) processedValues =
>   if indentLevel toks > topLevel
>   then processToks (processedToks++(toks:[])) tokss topLevel (ValueWithType typeToDate) processedValues
>   else 

When processing that value, we can either complete the opperation in this round, if we find a <<, or we have to continue building our list of depends untill we come to a <<.

>    case scoopDeclarationAndDependsWithRename toks of
>     Left (False, (name:depends),toks') -> processToks (processedToks++(toks':[])) tokss topLevel (ValueWithTypeAndNameAndDepends typeToDate name depends) processedValues
>     Left (True, (name:depends),toks') -> processToks (processedToks++(toks':[])) tokss topLevel ValueBody ((Value typeToDate name depends):processedValues)
>     Left (_, [],_)   -> Right ("Error parsing line:\n"++(toksOut toks)++"\nExpected a value declaration, no viable value name found.")
>     Right scoopError -> Right scoopError

This only happens if we have multiple lines before the <<

>  processToks processedToks (toks:tokss) topLevel (ValueWithTypeAndNameAndDepends typeToDate name depends) processedValues =
>   case scoopDeclarationAndDepends toks of
>    Left (True,depends',toks') ->
>     processToks (processedToks++(toks':[])) tokss topLevel ValueBody ((Value typeToDate name (depends++depends')):processedValues)
>    Left (False,depends',toks') ->
>     processToks (processedToks++(toks':[])) tokss topLevel (ValueWithTypeAndNameAndDepends typeToDate name (depends++depends')) processedValues
>    Right scoopError -> Right scoopError

Here we eat the body of the value, if any.

>  processToks processedToks (toks:tokss) topLevel ValueBody processedValues =
>   if indentLevel toks /= topLevel

We actually end up just ignoring the body of the value declaration.

>   then processToks (processedToks++(toks:[])) tokss topLevel ValueBody processedValues
>   else processToks processedToks (toks:tokss) topLevel NoValue processedValues

If we run out of lines to process, then we're done :)

>  processToks processedToks [] topLevel NoValue processedValues = Left (processedValues,tokssOut processedToks,topLevel)
>  processToks processedToks [] topLevel ValueBody processedValues = Left (processedValues,tokssOut processedToks,topLevel)

>  processToks processedToks [] topLevel valueBuilder processedValues = Right ("Incomplete Value declaration, end of file reached unexpectedly. The final value builder object was:\n"++(show valueBuilder))
>   
> in eatTillLidFoundThenContinueProcessingNormally [] tokss

| From a line like:

foo someDepend anotherDepend << bar

scoop the name and the depends returning:

Left (True,"foo",["someDepend","anotherDepend"])

From a line like:

foo someDepend
    anotherDepend << Bar

Return:

Left (False,"foo",["someDepend"])

>scoopDeclarationAndDepends :: [Tok] -> Either (Bool,[String],[Tok]) Error
>scoopDeclarationAndDepends toks = scoopDeclarationAndDepends' toks id [] []

Because we would get conflicting names if our functions where named the same as the values(record selectors) that they produced, we have to rename the functions.

>scoopDeclarationAndDependsWithRename :: [Tok] -> Either (Bool,[String],[Tok]) Error
>scoopDeclarationAndDependsWithRename toks = scoopDeclarationAndDepends' toks (\name->name++"Value") [] []

>scoopDeclarationAndDepends' :: [Tok] -> (String->String) -> [String] -> [Tok] -> Either (Bool,[String],[Tok]) Error
>scoopDeclarationAndDepends' ((Lid name):toks) rename [] processedToks = scoopDeclarationAndDepends' toks rename (name:[]) (processedToks++((Lid (rename name)):[]))
>scoopDeclarationAndDepends' ((Lid nameOrDepend):toks) rename nameAndDepends processedToks = scoopDeclarationAndDepends' toks rename (nameAndDepends++(nameOrDepend:[])) (processedToks++((Lid nameOrDepend):[]))
>scoopDeclarationAndDepends' ((Sym "<<"):toks) _ nameAndDepends processedToks = Left (True,nameAndDepends, (processedToks++((Sym "= "):toks)))
>scoopDeclarationAndDepends' (spc@(Spc _):toks) rename nameAndDepends processedToks = scoopDeclarationAndDepends' toks rename nameAndDepends (processedToks++(spc:[]))
>scoopDeclarationAndDepends' (nl@(NL _):toks) rename nameAndDepends processedToks = scoopDeclarationAndDepends' toks rename nameAndDepends (processedToks++(nl:[]))
>scoopDeclarationAndDepends' [] _ nameAndDepends processedToks= Left (False,nameAndDepends,processedToks)
>scoopDeclarationAndDepends' (tok:toks) rename nameAndDepends processedToks = Right ("Error, unexpected symbol in value declaration:\n"++(toksOut (tok:toks))++"\nThe symble was:\n"++(show tok))


>indentLevel :: [Tok] -> Int 
>indentLevel (nl@(NL _):spc@(Spc indent):toks) = length indent
>indentLevel (nl@(NL _):toks) = 0
>indentLevel [] = 0

>generateInit :: [Value] -> Int -> String
>generateInit values topLevel =
> (replicate topLevel ' ') ++ "initValues :: IO Values\n"++
> (replicate topLevel ' ')++"initValues = do\n"++
> concatMap (\value ->initValueCode value topLevel) values ++
> (replicate (topLevel+1) ' ')++"return $ Values"++ (concatMap (\value->' ':(valueName value)) values) ++ "\n"

>initValueCode :: Value -> Int -> String
>initValueCode (Value valueType name depends) topLevel =
> (replicate (topLevel+1)' ') ++ name ++ " <- " ++ (name++"Value") ++ (concatMap (\depend -> ' ':depend ++ " ") depends) ++ "\n"

>generateDataDeclaration :: [Value] -> Int -> String
>generateDataDeclaration values topLevel =
> (replicate topLevel ' ')++"data Values = Values {\n" ++
> (tail (concatMap (\(Value valueType valueName _) -> ',':valueName ++ "::" ++ (clipType valueType)++"\n") values)) ++
> " }\n"

>clipType :: [Tok] -> String
>clipType toks =
> let

First we split our type string so that we can focus on the last bit which is the only bit we are intrested in.

>  splitByArrows =
>   split (whenElt 
>           (\tok-> case tok of 
>                    (Sym "->") -> True 
>                    _ -> False))
>         toks 
> in
>  case reverse splitByArrows of
>   (lastType:_) ->

Then we remove that IO and convert the toks into a string of code(getting rid of any new lines).

>    toksOut $ 
>     filter (\elem -> case elem of
>                       (NL _) -> False
>                       _ -> True) $

>    (fst $ foldl (\(foldedToks,found) elem->
>            if not found && elem == (Uid "IO")
>            then (foldedToks,True)
>            else (foldedToks++(elem:[]),found))
>          ([],False)
>          lastType)

>mainCode :: Int -> String
>mainCode topLevel = 
> (replicate topLevel ' ') ++ "main :: IO ()\n"++
> (replicate topLevel ' ')++"main = do myValues <- initValues ; (exit myValues) ; return ()\n"

>resolveDependencies :: [Value] -> Either [Value] Error
>resolveDependencies values =
> let
>  sortedValues :: [Value]

Don't be scared, we're just converting the Value's to tuples and back again, so we can use the graph lib to sort this "topoligically".

>  sortedValues = reverse $ map (\(n,k,ks)-> Value n k ks) $ (\(g,v,_)->map v $ topSort g) $ graphFromEdges $ map (\(Value valueType valueName valueDepends) -> (valueType,valueName,valueDepends)) values
>  dependencyErrorMaybe :: Maybe Error
>  dependencyErrorMaybe = Nothing
> in
>  case dependencyErrorMaybe of
>   Just dependecyError -> Right dependecyError
>   Nothing -> Left sortedValues
